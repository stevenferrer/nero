// Code generated by nero, DO NOT EDIT.
package playerrepo

import (
	"time"

	"github.com/stevenferrer/nero/predicate"
	"github.com/stevenferrer/nero/test/demo-test/playerpkg"
)

// IDEq equal operator on ID field
func IDEq(id string) predicate.Func {
	return func(predicates []predicate.Predicate) []predicate.Predicate {
		return append(predicates, predicate.Predicate{
			Field:    "id",
			Operator: predicate.Eq,
			Argument: id,
		})
	}
}

// IDNotEq not equal operator on ID field
func IDNotEq(id string) predicate.Func {
	return func(predicates []predicate.Predicate) []predicate.Predicate {
		return append(predicates, predicate.Predicate{
			Field:    "id",
			Operator: predicate.NotEq,
			Argument: id,
		})
	}
}

// IDIn in operator on ID field
func IDIn(ids ...string) predicate.Func {
	args := []interface{}{}
	for _, v := range ids {
		args = append(args, v)
	}

	return func(predicates []predicate.Predicate) []predicate.Predicate {
		return append(predicates, predicate.Predicate{
			Field:    "id",
			Operator: predicate.In,
			Argument: args,
		})
	}
}

// IDNotIn not in operator on ID field
func IDNotIn(ids ...string) predicate.Func {
	args := []interface{}{}
	for _, v := range ids {
		args = append(args, v)
	}

	return func(predicates []predicate.Predicate) []predicate.Predicate {
		return append(predicates, predicate.Predicate{
			Field:    "id",
			Operator: predicate.NotIn,
			Argument: args,
		})
	}
}

// EmailEq equal operator on Email field
func EmailEq(email string) predicate.Func {
	return func(predicates []predicate.Predicate) []predicate.Predicate {
		return append(predicates, predicate.Predicate{
			Field:    "email",
			Operator: predicate.Eq,
			Argument: email,
		})
	}
}

// EmailNotEq not equal operator on Email field
func EmailNotEq(email string) predicate.Func {
	return func(predicates []predicate.Predicate) []predicate.Predicate {
		return append(predicates, predicate.Predicate{
			Field:    "email",
			Operator: predicate.NotEq,
			Argument: email,
		})
	}
}

// EmailIn in operator on Email field
func EmailIn(emails ...string) predicate.Func {
	args := []interface{}{}
	for _, v := range emails {
		args = append(args, v)
	}

	return func(predicates []predicate.Predicate) []predicate.Predicate {
		return append(predicates, predicate.Predicate{
			Field:    "email",
			Operator: predicate.In,
			Argument: args,
		})
	}
}

// EmailNotIn not in operator on Email field
func EmailNotIn(emails ...string) predicate.Func {
	args := []interface{}{}
	for _, v := range emails {
		args = append(args, v)
	}

	return func(predicates []predicate.Predicate) []predicate.Predicate {
		return append(predicates, predicate.Predicate{
			Field:    "email",
			Operator: predicate.NotIn,
			Argument: args,
		})
	}
}

// NameEq equal operator on Name field
func NameEq(name string) predicate.Func {
	return func(predicates []predicate.Predicate) []predicate.Predicate {
		return append(predicates, predicate.Predicate{
			Field:    "name",
			Operator: predicate.Eq,
			Argument: name,
		})
	}
}

// NameNotEq not equal operator on Name field
func NameNotEq(name string) predicate.Func {
	return func(predicates []predicate.Predicate) []predicate.Predicate {
		return append(predicates, predicate.Predicate{
			Field:    "name",
			Operator: predicate.NotEq,
			Argument: name,
		})
	}
}

// NameIn in operator on Name field
func NameIn(names ...string) predicate.Func {
	args := []interface{}{}
	for _, v := range names {
		args = append(args, v)
	}

	return func(predicates []predicate.Predicate) []predicate.Predicate {
		return append(predicates, predicate.Predicate{
			Field:    "name",
			Operator: predicate.In,
			Argument: args,
		})
	}
}

// NameNotIn not in operator on Name field
func NameNotIn(names ...string) predicate.Func {
	args := []interface{}{}
	for _, v := range names {
		args = append(args, v)
	}

	return func(predicates []predicate.Predicate) []predicate.Predicate {
		return append(predicates, predicate.Predicate{
			Field:    "name",
			Operator: predicate.NotIn,
			Argument: args,
		})
	}
}

// AgeEq equal operator on Age field
func AgeEq(age int) predicate.Func {
	return func(predicates []predicate.Predicate) []predicate.Predicate {
		return append(predicates, predicate.Predicate{
			Field:    "age",
			Operator: predicate.Eq,
			Argument: age,
		})
	}
}

// AgeNotEq not equal operator on Age field
func AgeNotEq(age int) predicate.Func {
	return func(predicates []predicate.Predicate) []predicate.Predicate {
		return append(predicates, predicate.Predicate{
			Field:    "age",
			Operator: predicate.NotEq,
			Argument: age,
		})
	}
}

// AgeGt greater than operator on Age field
func AgeGt(age int) predicate.Func {
	return func(predicates []predicate.Predicate) []predicate.Predicate {
		return append(predicates, predicate.Predicate{
			Field:    "age",
			Operator: predicate.Gt,
			Argument: age,
		})
	}
}

// AgeGtOrEq greater than or equal operator on Age field
func AgeGtOrEq(age int) predicate.Func {
	return func(predicates []predicate.Predicate) []predicate.Predicate {
		return append(predicates, predicate.Predicate{
			Field:    "age",
			Operator: predicate.GtOrEq,
			Argument: age,
		})
	}
}

// AgeLt less than operator on Age field
func AgeLt(age int) predicate.Func {
	return func(predicates []predicate.Predicate) []predicate.Predicate {
		return append(predicates, predicate.Predicate{
			Field:    "age",
			Operator: predicate.Lt,
			Argument: age,
		})
	}
}

// AgeLtOrEq less than or equal operator on Age field
func AgeLtOrEq(age int) predicate.Func {
	return func(predicates []predicate.Predicate) []predicate.Predicate {
		return append(predicates, predicate.Predicate{
			Field:    "age",
			Operator: predicate.LtOrEq,
			Argument: age,
		})
	}
}

// AgeIn in operator on Age field
func AgeIn(ages ...int) predicate.Func {
	args := []interface{}{}
	for _, v := range ages {
		args = append(args, v)
	}

	return func(predicates []predicate.Predicate) []predicate.Predicate {
		return append(predicates, predicate.Predicate{
			Field:    "age",
			Operator: predicate.In,
			Argument: args,
		})
	}
}

// AgeNotIn not in operator on Age field
func AgeNotIn(ages ...int) predicate.Func {
	args := []interface{}{}
	for _, v := range ages {
		args = append(args, v)
	}

	return func(predicates []predicate.Predicate) []predicate.Predicate {
		return append(predicates, predicate.Predicate{
			Field:    "age",
			Operator: predicate.NotIn,
			Argument: args,
		})
	}
}

// RaceEq equal operator on Race field
func RaceEq(race playerpkg.Race) predicate.Func {
	return func(predicates []predicate.Predicate) []predicate.Predicate {
		return append(predicates, predicate.Predicate{
			Field:    "race",
			Operator: predicate.Eq,
			Argument: race,
		})
	}
}

// RaceNotEq not equal operator on Race field
func RaceNotEq(race playerpkg.Race) predicate.Func {
	return func(predicates []predicate.Predicate) []predicate.Predicate {
		return append(predicates, predicate.Predicate{
			Field:    "race",
			Operator: predicate.NotEq,
			Argument: race,
		})
	}
}

// RaceIn in operator on Race field
func RaceIn(races ...playerpkg.Race) predicate.Func {
	args := []interface{}{}
	for _, v := range races {
		args = append(args, v)
	}

	return func(predicates []predicate.Predicate) []predicate.Predicate {
		return append(predicates, predicate.Predicate{
			Field:    "race",
			Operator: predicate.In,
			Argument: args,
		})
	}
}

// RaceNotIn not in operator on Race field
func RaceNotIn(races ...playerpkg.Race) predicate.Func {
	args := []interface{}{}
	for _, v := range races {
		args = append(args, v)
	}

	return func(predicates []predicate.Predicate) []predicate.Predicate {
		return append(predicates, predicate.Predicate{
			Field:    "race",
			Operator: predicate.NotIn,
			Argument: args,
		})
	}
}

// UpdatedAtEq equal operator on UpdatedAt field
func UpdatedAtEq(updatedAt *time.Time) predicate.Func {
	return func(predicates []predicate.Predicate) []predicate.Predicate {
		return append(predicates, predicate.Predicate{
			Field:    "updated_at",
			Operator: predicate.Eq,
			Argument: updatedAt,
		})
	}
}

// UpdatedAtNotEq not equal operator on UpdatedAt field
func UpdatedAtNotEq(updatedAt *time.Time) predicate.Func {
	return func(predicates []predicate.Predicate) []predicate.Predicate {
		return append(predicates, predicate.Predicate{
			Field:    "updated_at",
			Operator: predicate.NotEq,
			Argument: updatedAt,
		})
	}
}

// UpdatedAtGt greater than operator on UpdatedAt field
func UpdatedAtGt(updatedAt *time.Time) predicate.Func {
	return func(predicates []predicate.Predicate) []predicate.Predicate {
		return append(predicates, predicate.Predicate{
			Field:    "updated_at",
			Operator: predicate.Gt,
			Argument: updatedAt,
		})
	}
}

// UpdatedAtGtOrEq greater than or equal operator on UpdatedAt field
func UpdatedAtGtOrEq(updatedAt *time.Time) predicate.Func {
	return func(predicates []predicate.Predicate) []predicate.Predicate {
		return append(predicates, predicate.Predicate{
			Field:    "updated_at",
			Operator: predicate.GtOrEq,
			Argument: updatedAt,
		})
	}
}

// UpdatedAtLt less than operator on UpdatedAt field
func UpdatedAtLt(updatedAt *time.Time) predicate.Func {
	return func(predicates []predicate.Predicate) []predicate.Predicate {
		return append(predicates, predicate.Predicate{
			Field:    "updated_at",
			Operator: predicate.Lt,
			Argument: updatedAt,
		})
	}
}

// UpdatedAtLtOrEq less than or equal operator on UpdatedAt field
func UpdatedAtLtOrEq(updatedAt *time.Time) predicate.Func {
	return func(predicates []predicate.Predicate) []predicate.Predicate {
		return append(predicates, predicate.Predicate{
			Field:    "updated_at",
			Operator: predicate.LtOrEq,
			Argument: updatedAt,
		})
	}
}

// UpdatedAtIsNull is null operator on UpdatedAt field
func UpdatedAtIsNull() predicate.Func {
	return func(predicates []predicate.Predicate) []predicate.Predicate {
		return append(predicates, predicate.Predicate{
			Field:    "updated_at",
			Operator: predicate.IsNull,
		})
	}
}

// UpdatedAtIsNotNull is not null operator on UpdatedAt field
func UpdatedAtIsNotNull() predicate.Func {
	return func(predicates []predicate.Predicate) []predicate.Predicate {
		return append(predicates, predicate.Predicate{
			Field:    "updated_at",
			Operator: predicate.IsNotNull,
		})
	}
}

// UpdatedAtIn in operator on UpdatedAt field
func UpdatedAtIn(updatedAts ...*time.Time) predicate.Func {
	args := []interface{}{}
	for _, v := range updatedAts {
		args = append(args, v)
	}

	return func(predicates []predicate.Predicate) []predicate.Predicate {
		return append(predicates, predicate.Predicate{
			Field:    "updated_at",
			Operator: predicate.In,
			Argument: args,
		})
	}
}

// UpdatedAtNotIn not in operator on UpdatedAt field
func UpdatedAtNotIn(updatedAts ...*time.Time) predicate.Func {
	args := []interface{}{}
	for _, v := range updatedAts {
		args = append(args, v)
	}

	return func(predicates []predicate.Predicate) []predicate.Predicate {
		return append(predicates, predicate.Predicate{
			Field:    "updated_at",
			Operator: predicate.NotIn,
			Argument: args,
		})
	}
}

// CreatedAtEq equal operator on CreatedAt field
func CreatedAtEq(createdAt *time.Time) predicate.Func {
	return func(predicates []predicate.Predicate) []predicate.Predicate {
		return append(predicates, predicate.Predicate{
			Field:    "created_at",
			Operator: predicate.Eq,
			Argument: createdAt,
		})
	}
}

// CreatedAtNotEq not equal operator on CreatedAt field
func CreatedAtNotEq(createdAt *time.Time) predicate.Func {
	return func(predicates []predicate.Predicate) []predicate.Predicate {
		return append(predicates, predicate.Predicate{
			Field:    "created_at",
			Operator: predicate.NotEq,
			Argument: createdAt,
		})
	}
}

// CreatedAtGt greater than operator on CreatedAt field
func CreatedAtGt(createdAt *time.Time) predicate.Func {
	return func(predicates []predicate.Predicate) []predicate.Predicate {
		return append(predicates, predicate.Predicate{
			Field:    "created_at",
			Operator: predicate.Gt,
			Argument: createdAt,
		})
	}
}

// CreatedAtGtOrEq greater than or equal operator on CreatedAt field
func CreatedAtGtOrEq(createdAt *time.Time) predicate.Func {
	return func(predicates []predicate.Predicate) []predicate.Predicate {
		return append(predicates, predicate.Predicate{
			Field:    "created_at",
			Operator: predicate.GtOrEq,
			Argument: createdAt,
		})
	}
}

// CreatedAtLt less than operator on CreatedAt field
func CreatedAtLt(createdAt *time.Time) predicate.Func {
	return func(predicates []predicate.Predicate) []predicate.Predicate {
		return append(predicates, predicate.Predicate{
			Field:    "created_at",
			Operator: predicate.Lt,
			Argument: createdAt,
		})
	}
}

// CreatedAtLtOrEq less than or equal operator on CreatedAt field
func CreatedAtLtOrEq(createdAt *time.Time) predicate.Func {
	return func(predicates []predicate.Predicate) []predicate.Predicate {
		return append(predicates, predicate.Predicate{
			Field:    "created_at",
			Operator: predicate.LtOrEq,
			Argument: createdAt,
		})
	}
}

// CreatedAtIsNull is null operator on CreatedAt field
func CreatedAtIsNull() predicate.Func {
	return func(predicates []predicate.Predicate) []predicate.Predicate {
		return append(predicates, predicate.Predicate{
			Field:    "created_at",
			Operator: predicate.IsNull,
		})
	}
}

// CreatedAtIsNotNull is not null operator on CreatedAt field
func CreatedAtIsNotNull() predicate.Func {
	return func(predicates []predicate.Predicate) []predicate.Predicate {
		return append(predicates, predicate.Predicate{
			Field:    "created_at",
			Operator: predicate.IsNotNull,
		})
	}
}

// CreatedAtIn in operator on CreatedAt field
func CreatedAtIn(createdAts ...*time.Time) predicate.Func {
	args := []interface{}{}
	for _, v := range createdAts {
		args = append(args, v)
	}

	return func(predicates []predicate.Predicate) []predicate.Predicate {
		return append(predicates, predicate.Predicate{
			Field:    "created_at",
			Operator: predicate.In,
			Argument: args,
		})
	}
}

// CreatedAtNotIn not in operator on CreatedAt field
func CreatedAtNotIn(createdAts ...*time.Time) predicate.Func {
	args := []interface{}{}
	for _, v := range createdAts {
		args = append(args, v)
	}

	return func(predicates []predicate.Predicate) []predicate.Predicate {
		return append(predicates, predicate.Predicate{
			Field:    "created_at",
			Operator: predicate.NotIn,
			Argument: args,
		})
	}
}

// FieldXEqFieldY fieldX equal fieldY
//
// fieldX and fieldY must be of the same type
func FieldXEqFieldY(fieldX, fieldY Field) predicate.Func {
	return func(predicates []predicate.Predicate) []predicate.Predicate {
		return append(predicates, predicate.Predicate{
			Field:    fieldX.String(),
			Operator: predicate.Eq,
			Argument: fieldY,
		})
	}
}

// FieldXNotEqFieldY fieldX not equal fieldY
//
// fieldX and fieldY must be of the same type
func FieldXNotEqFieldY(fieldX, fieldY Field) predicate.Func {
	return func(predicates []predicate.Predicate) []predicate.Predicate {
		return append(predicates, predicate.Predicate{
			Field:    fieldX.String(),
			Operator: predicate.NotEq,
			Argument: fieldY,
		})
	}
}

// FieldXGtFieldY fieldX greater than fieldY
//
// fieldX and fieldY must be of the same type
func FieldXGtFieldY(fieldX, fieldY Field) predicate.Func {
	return func(predicates []predicate.Predicate) []predicate.Predicate {
		return append(predicates, predicate.Predicate{
			Field:    fieldX.String(),
			Operator: predicate.Gt,
			Argument: fieldY,
		})
	}
}

// FieldXGtOrEqFieldY fieldX greater than or equal fieldY
//
// fieldX and fieldY must be of the same type
func FieldXGtOrEqFieldY(fieldX, fieldY Field) predicate.Func {
	return func(predicates []predicate.Predicate) []predicate.Predicate {
		return append(predicates, predicate.Predicate{
			Field:    fieldX.String(),
			Operator: predicate.GtOrEq,
			Argument: fieldY,
		})
	}
}

// FieldXLtFieldY fieldX less than fieldY
//
// fieldX and fieldY must be of the same type
func FieldXLtFieldY(fieldX, fieldY Field) predicate.Func {
	return func(predicates []predicate.Predicate) []predicate.Predicate {
		return append(predicates, predicate.Predicate{
			Field:    fieldX.String(),
			Operator: predicate.Lt,
			Argument: fieldY,
		})
	}
}

// FieldXLtOrEqFieldY fieldX less than or equal fieldY
//
// fieldX and fieldY must be of the same type
func FieldXLtOrEqFieldY(fieldX, fieldY Field) predicate.Func {
	return func(predicates []predicate.Predicate) []predicate.Predicate {
		return append(predicates, predicate.Predicate{
			Field:    fieldX.String(),
			Operator: predicate.LtOrEq,
			Argument: fieldY,
		})
	}
}
